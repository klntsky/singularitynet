\documentclass[10pt, a4paper]{article}
\usepackage{minted}
\usepackage{amsmath} 
\usepackage[english]{babel}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{color}
\usepackage[linkbordercolor={0.03 .4 .75}, urlbordercolor={0.03 .4 .75}]{hyperref}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{setspace}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{\huge \textbf{\texttt{SingularityNet} Unbonded Staking Pool Technical Specification}}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
\href{https://github.com/Plutonomicon/plutarch}{\texttt{Plutarch}} is an eDSL in Haskell
for writing on-chain scripts on Cardano. The intention is to write \texttt{SingularityNet}'s unbonded stake pool code in \texttt{Plutarch} for optimised script size \& execution units, thus reducing transaction fees compared to \texttt{PlutusTx}.

Production off chain code will be written in \href{https://github.com/Plutonomicon/cardano-browser-tx/}{\texttt{Cardano Transaction Library (CTL)}}, an API to balance and submit transactions using browser-integrated wallets and \href{https://ogmios.dev/getting-started/basics/}{\texttt{Ogmios}}.

\begin{definition}[\texttt{NFT State UTXO}]\label{def:NFTState} A common design pattern in Plutus contract involves minting an NFT with a (unique) currency symbol which parametrises the validator (staking pool) in question. This is just a UTXO with the unit value for this currency symbol (and a fixed token name), for us, the datum injectively corresponds to an associated list (a \texttt{Map}). We'll refer to this UTXO as the \textbf{NFT State UTXO}.
\end{definition}

\begin{definition}[\texttt{Assoc. List UTXO}]\label{def:AssocListUTXO} This spec. adapts an \href{https://github.com/Plutonomicon/plutonomicon/blob/main/assoc.md}{on-chain associated list}. The UTXOs used for elements of the list will be called \textbf{Assoc. List UTXOs}. Its \texttt{CurrencySymbol} is given by \texttt{assocListCs} in Definition~\ref{def:assocListCs} with \texttt{TokenName = TokenName hashedPkh}, for \texttt{hashedPkh} in Definition~\ref{def:hashedPkh}. Its datum is \texttt{EntryDatum} in Definition~\ref{def:EntryDatum}.
\end{definition}

We may sometimes interchange the word ``Token" and ``UTXO" although this can sometimes be confusing, so we will try to stick to ``UTXO".

\textbf{Aim}: to write a unbonded staking pool for \texttt{SingularityNet}'s \texttt{AGIX} token.

\section{Minting Policies}\label{section:MintingPolicies}
\subsection{NFT State Minting Policy}\label{subsection:NFTStateMintingPolicy}
\textbf{This subsection is identical to that of bonded staking except for the hardcoded \texttt{TokenName}.}

This is a standard (genuine) NFT minting policy parametrised over \texttt{TxOutRef} and optionally \texttt{TokenName} with the former used for uniqueness of the NFT \texttt{CurrencySymbol}. The \texttt{TokenName} can be globally hardcoded to ``\texttt{UnbondedStaking}'' for example.

On-chain minting conditions:
\begin{itemize}
\item{The parameterised UTXO (\texttt{TxOutRef}) is part of the transaction inputs}
\item{\texttt{txInfoMint} contains exactly one \texttt{AssetClass} of \textit{unit} value. The \texttt{ownCurrencySymbol} with the hardcoded \texttt{TokenName} matches the aforementioned \texttt{AssetClass}}
\item{The minting policy can optionally ensure the initial datum is \texttt{StateDatum Nothing True} (see Definition \ref{def:StateDatum}) although we cannot verify the validator address as this would cause mutual recursion}
\end{itemize}
\begin{definition}[\texttt{nftCs}]\label{def:nftCs} this minting policy creates a genuine NFT (by virtue of the UTXO parameter) with a \texttt{CurrencySymbol} that cannot be reproduced. We will call this the \textbf{nftCs}.
\end{definition}

\subsection{Associated List Minting Policy}\label{subsection:AssociatedListMintingPolicy}
\textbf{This subsection is identical to that of bonded staking.}

The minting policy is parameterised by \texttt{nftCs} from Definition~\ref{def:nftCs}. The uniqueness of the \texttt{nftCs} means the currency symbol of this minting policy is unique, constant and injectively associated to the NFT State UTXO.
On-chain minting conditions
\begin{itemize}
\item{Check \texttt{txInfoSignatories} is a singleton list, the individual \texttt{PaymentPubKeyHash}'s underlying \texttt{BuiltinByteString} should be \texttt{blake2b\_256} hashed to create a \texttt{TokenName} after rewrapping, see Definition~\ref{def:hashedPkh}. This of course implies the transaction should be signed by only this user}
\item{\texttt{txInfoMint} contains exactly one \texttt{AssetClass} of $\pm 1$ value (burning is allowed). The \texttt{ownCurrencySymbol} with \texttt{TokenName} above matches the aforementioned \texttt{AssetClass}}
\item{The relevant inductive condition within Section~\ref{section:Induction} is met}
\end{itemize}

This minting policy will mint value for UTXOs that form the associated list. Minting means adding to the associated list, whilst burning means removing from the associated list.

Note that this token can only be minted if the NFT State UTXO is initially at the validator address, so by induction, we have a unique and identifiable associated list for each staking pool.

\begin{definition}[\texttt{hashedPkh}]\label{def:hashedPkh} the pattern of taking a \texttt{PaymentPubKeyHash} and \texttt{blake2b\_256} hashing the underlying \texttt{BuiltinByteString} to create another \texttt{BuiltinByteString} will be a common pattern. This will be used for creating \texttt{TokenName}s as above but also as \texttt{key}s for each \texttt{Entry}, see \texttt{key} in Definition~\ref{def:Entry}. We will refer to the output \texttt{BuiltinByteString} as \textbf{hashedPkh}.
\end{definition}

\begin{definition}[\texttt{assocListCs}]\label{def:assocListCs} this minting policy has a \texttt{CurrencySymbol} that we define as \textbf{assocListCs}. This \texttt{CurrencySymbol} is unqiuely associated to the original NFT State UTXO and provides a \texttt{CurrencySymbol} for each associated list element (with different \texttt{TokenName} per user).
\end{definition}

\section{Datums}
\textbf{This section is different to that of bonded staking.}

\begin{minted}{haskell}
data UnbondedStakingDatum
   = StateDatum (Maybe BuiltinByteString) Bool
   | EntryDatum Entry
   | AssetDatum

\end{minted}

\begin{definition}[\texttt{StateDatum}]\label{def:StateDatum} This represents the staking pool/associated list and is datum for the NFT State UTXO. \texttt{Nothing} says the list is empty, \texttt{Just} the key (corresponding to \texttt{TokenName}) to the head of the associated list. We do not keep track of size here (compared to bonded) because the unbonded pool has no limit.

Recall the \texttt{AssetClass} for the NFT State comes from Subsection~\ref{subsection:NFTStateMintingPolicy} with hardcoded \texttt{TokenName}. However, the \texttt{TokenName} inside \texttt{Maybe} is a hashed \texttt{PaymentPubKeyHash}, see Definition~\ref{def:hashedPkh}. The \texttt{Bool} represents the state of the pool, \texttt{True} means the pool is open, otherwise closed. This should be initiated to \texttt{True}.
\end{definition}

\begin{definition}[\texttt{EntryDatum}]\label{def:EntryDatum} a wrapper over the \texttt{Entry} type found in Definition~\ref{def:Entry}.
\end{definition}

\begin{definition}[\texttt{AssetDatum}]\label{def:AssetDatum} is the datum for staked asset UTXOs at the script address, acting as dummy datum.
\end{definition}

\begin{minted}{haskell}
data Entry = Entry
  { key :: BuiltinByteString
  , deposited :: Natural
  , newDeposit :: Natural
  , rewards :: NatRatio
  , totalRewards :: Natural
  , totalDeposited :: Natural
  , open :: Bool
  , next :: Maybe BuiltinByteString
  }
\end{minted}
\begin{definition}[\texttt{Entry}]\label{def:Entry}
\end{definition} is the entry of the associated map in question. The UTXO with this datum should have \texttt{CurrencySymbol},  \texttt{assocListCs} from Definition~\ref{def:assocListCs} and \texttt{TokenName = TokenName key}.

\begin{definition}[\texttt{key}]\label{def:key}
is given by the \texttt{blake2b\_256} hash of the \texttt{PaymentPubKeyHash} of the minting/burning user in question, see Definition~\ref{def:hashedPkh}. 
\end{definition}

\begin{definition}[\texttt{deposited}]\label{def:deposited} how much a user has deposited so far for staking, we do not have a \texttt{staked} field like the bonded case, because of unlimited pool size.
\end{definition}

\begin{definition}[\texttt{newDeposit}]\label{def:newDeposit} tells the admin whether or not the user deposited in the recent cycle. 0 means they have not deposited in the recent cycle, \texttt{nonZero} means they have deposited \texttt{nonZero} in the recent cycle. This is needed for the admin to calculate rewards from the previous cycle if the user did not withdraw. This prevents confusion because the user could deposit in the new cycle but this should not count towards rewards in the previous cycle (from previous deposits) during the \texttt{rewards} update.
\end{definition}

\begin{definition}[\texttt{rewards}]\label{def:rewards}
These are rewards accrued so far (across different cycles). This is updated by the admin during the admin deposit phase. This should be initiated to zero for new user deposits and unchanged for further deposits. This can be thought of as a lower bound for rewards at the start of a new cycle, basically all rewards accrued so far from \textit{previous} cycles. Once the bonding period restarts for the upcoming cycle, the rewards will be greater or equal to this field. This is required as we do not have timestamped deposits. You can think of it like Markov chain (without the probablistic element) where we only care about the current state. See Subsection~\ref{subsection:Example} for an example.
\end{definition}

\begin{definition}[\texttt{totalRewards}]\label{def:totalRewards} how much the admin deposited during the admin cycle for upcoming rewards in this withdrawal cycle.
\end{definition}

\begin{definition}[\texttt{totalDeposited}]\label{def:totalDeposited} how much users have deposited (including their rewards so far) for this withdrawal/deposit cycle, allowing the user to proportionally work out their rewards.
\end{definition}

\begin{definition}[\texttt{open}]\label{def:open}
the state of the pool, \texttt{True} means the pool is open and otherwise closed. Only the admin can change the state of the pool. This is initiated to \texttt{True} by induction.
\end{definition}

\begin{definition}[\texttt{next}]\label{def:next}
a pointer to the \texttt{key} of the next UTXO in the associated list. \texttt{Nothing} indicates we are at the tail.
\end{definition}

\section{Redeemers}
\subsection{Minting Redeemers}
\textbf{This subsection is identical to that of bonded staking.}

\begin{minted}{haskell}
data MintingAction
   = Stake
   | Withdraw
\end{minted}
\begin{definition}[\texttt{Stake}]\label{def:Stake} redeemer used for staking (minting +1) and creating a UTXO for the associated list.
\end{definition}

\begin{definition}[\texttt{Withdraw}]\label{def:Withdraw} redeemer used for withdrawing (burning +1) and removing a UTXO from the associated list.
\end{definition}

These redeemers should be used with the associated list minting policy in Subsection~\ref{subsection:AssociatedListMintingPolicy}.

Since minting checks are forwarded to the validator, these redeemers could be deemed unnecessary, we can keep them for now to show intent.

\subsection{Validator Redeemers}
\textbf{This subsection is different to that of bonded staking.}

\begin{minted}{haskell}
data UnbondedStakingAction
   = AdminAct Natural Natural -- (totalRewards totalDeposited) for updating UTXOs 
   -- and depositing rewards
   | StakeAct Natural PaymentPubKeyHash
   | WithdrawAct PaymentPubKeyHash
   | CloseAct
\end{minted}

\begin{definition}[\texttt{AdminAct}]\label{def:AdminAct} redeemer for the \textbf{Admin} to deposit staking tokens to the validator and update rewards for each users Assoc. List UTXO. The first parameter signifies how much rewards will be added for the upcoming cycle. The second parameter signifies how much has been deposited (including rewards) in total. These respectively fill out \texttt{totalRewards} and \texttt{totalDeposited} in \texttt{EntryDatum}.
\end{definition}

\begin{definition}[\texttt{StakeAct}]\label{def:StakeAct} redeemer for staking tokens with \texttt{PaymentPubKeyHash} of \texttt{Natural} amount.
\end{definition}

\begin{definition}[\texttt{WithdrawAct}]\label{def:WithdrawAct} redeemer for withdrawing \textit{all} staked tokens and rewards for a given user's \texttt{PaymentPubKeyHash}. This can be called when the pool is both open or closed.
\end{definition}

\begin{definition}[\texttt{CloseAct}]\label{def:CloseAct} redeemer for the admin to close the stake pool (for now, the users should then withdraw the tokens themselves). This is callable only during the admin phase to prevent contention.
\end{definition}

\section{Initialisation}\label{section:initialisation}
\textbf{This section is different to that of bonded staking.}
\subsection{Minting NFT State}\label{subsection:mintNft}

Off-chain logic is required by the administrator/operator to initially mint an NFT with the following datum (see Definition~\ref{def:StateDatum}):
\begin{minted}{haskell}
StateDatum Nothing True
\end{minted}
defining the on-chain associated list of validator/stake pool. The NFT \texttt{TokenName} can be hardcoded to ``\texttt{UnbondedStaking}'' or anything else, provided it's fixed for the codebase. The Boolean is default to \texttt{True} to show the pool is open.

On-chain \texttt{Map}s can theoretically increase the transaction size to no end.  This technical spec will implement an adapted version of the  \href{https://github.com/Plutonomicon/plutonomicon/blob/main/assoc.md}{on-chain associated list}.


\subsection{Validator Parameters}\label{subsection:validatorParams}
\textbf{This subsection is different to that of bonded staking.}

The currency symbol of the NFT then parametrises the validator as follows:
\begin{minted}{haskell}
data UnbondedPoolParams = UnbondedPoolParams
  { upp'start :: POSIXTime -- absolute time
  , upp'userLength :: POSIXTime -- a time delta
  , upp'adminLength  :: POSIXTime -- a time delta
  , upp'bondingLength :: POSIXTime -- a time delta
  , upp'interestLength :: POSIXTime -- a time delta
  , upp'increments :: Natural
  , upp'interest :: NatRatio -- interest per increment
  , upp'minStake :: Natural
  , upp'maxStake :: Natural
  , upp'admin :: PaymentPubKeyHash
  , upp'unbondedAssetClass :: AssetClass
  , upp'nftCs :: CurrencySymbol -- this uniquely parameterises the validator
  , upp'assocListCs :: CurrencySymbol -- CurrencySymbol for on-chain associated list UTXOs
 }
\end{minted}
The parameters are configurable by the administrator/operator at the start and fixed for the duration of the staking period.

These parameters are visualised in Equations~\ref{eqn:startCycles}, \ref{eqn:bondingCycle}.

\begin{definition}[\texttt{upp'start}]\label{def:upp'start}
the \textit{absolute} \texttt{POSIXTime} the staking pool starts (the first cycle), i.e. when staking deposits can be taken from users for the first cycle.
\end{definition}

\begin{definition}[\texttt{upp'userLength}]\label{def:upp'userLength}
the \textit{timedelta} for how long users can deposit (for the upcoming cycle) Should be thought of a positive number that can be added to some other starting point (as opposed to a fixed \texttt{POSIXTimeRange}). We could also use \texttt{Natural} or \texttt{Integer} for any subsequent ``timedelta".  Withdrawing during this phase will not give rewards unless they were already previously earned. In particular, a user can make a new deposit in this phase and withdraw at the same time, and their recent deposit should not accrue rewards. 
\end{definition}

\begin{definition}[\texttt{upp'adminLength}]\label{def:upp'adminLength}
the \textit{timedelta} for the admin to update UTXOs on chain. In particular, the admin should update \texttt{rewards}, reset Assoc. List UTXO's \texttt{newDeposit} to zero, update the global \texttt{totalRewards} and \texttt{totalDeposited}.
\end{definition}

\begin{definition}[\texttt{upp'bondingLength}]\label{def:upp'bondingLength}
the \textit{timedelta} for how long bonding can occur for a given cycle. The user can withdraw during this phase (unlike bonded) with rewards determined by the approximate (discretised) time they withdraw.
\end{definition}

\begin{definition}[\texttt{upp'interestLength}]\label{def:upp'interestLength}
the \textit{timedelta} for the discretised intervals for earning rewards. Because we cannot have a notion of continuous absolute time on chain, we need to discretise into intervals. We require  $\texttt{upp'interestLength} \leq \texttt{upp'bondingLength}$ and \texttt{upp'bondingLength} is divisible by $\texttt{upp'interestLength}$. Rewards are then determined and ``rounded to the nearest discretised interval".
\end{definition}


\begin{definition}[\texttt{upp'increments}]\label{def:upp'increments}
$\frac{\texttt{upp'bondingLength}} {\texttt{upp'interestLength}}$ which should be exactly divisible. This is for on-chain convenience. If the user decides to withdraw during \texttt{upp'bondingLength}, the updated rewards can be calculated as $\texttt{rewards} + (\texttt{deposited} + \texttt{rewards})* (1 + \texttt{upp'interest})^k$ where $1 \leq k \leq \texttt{upp'increments}.$ Note that by this stage, \texttt{newDeposit} should be initially zero or reset to zero by the admin.
\end{definition}

\begin{definition}[\texttt{upp'interest}]\label{def:upp'interest}
a positive (non-zero) ratio fixed decimal. This is fixed rate for one time increment in annual percentage yield.
\end{definition}

\begin{definition}[\texttt{upp'minStake}]\label{def:upp'minStake}
minimum amount required to stake by a wallet.
\end{definition}

\begin{definition}[\texttt{upp'maxStake}]\label{def:upp'maxStake}
maximum amount possible to stake by a wallet.
\end{definition}

\begin{definition}[\texttt{upp'admin}]\label{def:upp'admin}
the \texttt{PaymentPubKeyHash} of the administrator.
\end{definition}

\begin{definition}[\texttt{upp'unbondedAssetClass}]\label{def:upp'unbondedAssetClass}
the asset class of the token being staked, i.e. \texttt{AGIX}.
\end{definition}

\begin{definition}[\texttt{upp'nftCs}]\label{def:upp'nftCs}
currency symbol of the NFT to identify the NFT state UTXO of the pool, see \texttt{StateDatum} in Definition~\ref{def:StateDatum}.
\end{definition}

\begin{definition}[\texttt{upp'assocListCs}]\label{def:upp'assocListCs}
currency symbol of the associated list UTXOs, see \texttt{EntryDatum} in Definition~\ref{def:EntryDatum}.
\end{definition}

\subsection{Initiate Staking Pool}
The following step should be taken to initiate the staking pool
\begin{itemize}
\item{The minted NFT from Subsection~\ref{subsection:mintNft} should be sent to the validator address determined by Subsection~\ref{subsection:validatorParams}. This of course requires determining \texttt{upp'assocListCs} which is possible after obtaining \texttt{upp'nftCs}.}
\end{itemize}

\section{Unbonded Staking Schema}
\textbf{This section is different to that of bonded staking.}

For reference, here is an example of just over one cycle/iteration

\begin{equation}\label{eqn:startCycles}
\hspace*{-1cm}
\texttt{upp'start} \underbrace{ \overbrace{\xrightarrow[\texttt{upp'userLength}] {Deposit/Withdraw\ 0}}^\texttt{No rewards} B 
  \overbrace{\xrightarrow[\texttt{upp'adminLength}] {Admin \ Updates \ 0}}^\texttt{Admin Deposits 0} C
\overbrace{\xrightarrow[\texttt{upp'bondingLength}]{Bonding/Withdraw \ 0}}^\texttt{Dynamic rewards}}_\texttt{cycle/iteration 0} D \overbrace{\xrightarrow[\texttt{upp'userLength}] {Deposit/Withdraw\ 1}}^\texttt{Previous rewards} E 
  \overbrace{\xrightarrow[\texttt{upp'adminLength}] {Admin \ Updates \ 1}}^\texttt{Admin Deposits 1} F \ldots
\end{equation}

Here's an explanation of the different windows:
\begin{itemize}
\item{Users deposit during the first \texttt{upp'userLength}, these would count towards \texttt{newDeposit} so no rewards are available yet. The only way to get rewards here is to have timestamped UTXOs which would increase complexity. A user could also withdraw their deposited amount here (again with no rewards).}
\item{Admin updates UTXOs during first \texttt{upp'adminLength}. Usually, the admin should increment \texttt{rewards} for the previous \texttt{upp'bondLength} (\textbf{none for the first cycle}), as well as \texttt{totalRewards} and \texttt{totalDeposited}. The latter two are determined off chain for the \textbf{upcoming} bonding cycle. \texttt{totalDeposited} should include rewards accrued so far so we get can proportionally get how much they own in total. The admin should also reset all \texttt{newDeposit}s to zero. This is needed because by the next \texttt{upp'userLength}, all new deposits need to be distinguishable from old deposits.}
\item{Bonding begins and the user can withdraw whenever, the longer they wait, the more they are rewarded. Rewards are rounded to the nearest discretised interval.}
\item{For the next \texttt{upp'userLength} cycle, the user reward is initially zero on the \texttt{EntryDatum}, but they can withdraw all the rewards from the previous bonding period. This is verfiable on chain using time checks. These rewards would be based on their \texttt{deposited} subtract any \texttt{newDeposit} from that round. Of course, they can make further deposits to \texttt{newDeposit} (and \texttt{deposited}) in this phase. \texttt{newDeposit} is required so they cannot get unearned rewards by depositing and withdrawing in this (same) phase.}
\item{The cycle repeats with admin deposits, and UTXO updates as before. This \texttt{upp'adminLength} should update \texttt{rewards} for the first bonding period, so we can forget about the first cycle. This removes the requirement for timestamped deposits as they are adjusted after every cycle. This however means rewards only accrue during \texttt{upp'bondingLength} and \textit{not} the other windows}
\end{itemize}

A diagramatic explanation for \texttt{upp'bondingLength}:
\begin{equation}\label{eqn:bondingCycle}
x_o \underbrace{\xrightarrow[\texttt{upp'interestLength}] {} x_1  \xrightarrow[\texttt{upp'interestLength}] {} x_2 \xrightarrow[\texttt{upp'interestLength}] {} x_3 \xrightarrow[\texttt{upp'interestLength}] {} x_4  \rightarrow \ldots}_\texttt{upp'bondingLength}
\end{equation}

The discretised interval the user falls into with their contract (which can be verified on chain)  will determine their rewards. This implies rewards are calculated approximately as we do not have a notion of verifiable (continuous) absolute time on chain. When a bonding stage is reached, the \texttt{rewards} field should be updated by the admin just prior (during the reccent admin stage), meaning (dynamic) rewards in this bonding cycle can be calculated from \texttt{deposited} and \texttt{rewards}.

If a user tries to withdraw during \texttt{upp'userLength}, they will have accrued rewards for previous \texttt{upp'bondingLength} periods and new deposits should not contribute. Of course, their first \texttt{upp'userLength} will have no rewards initially. This is reflected in the first \texttt{upp'adminLength} where rewards must be zero for everyone.

\subsection{Example}\label{subsection:Example}
Here is an example for one user:
\begin{enumerate}
\item{\texttt{upp'userLength} 0
\begin{itemize}
\item{User mints an Assoc. List UTXO depositing 5 tokens. Make sure \texttt{open} is the same as neighbouring \texttt{open}s and \texttt{True}. \texttt{totalRewards} and \texttt{totalDeposited} can either be zero or taken from neighbours (we'll choose zero), these values are meaningless until the admin cleans them up to for global consistency. Ensure \texttt{rewards} is initiated to zero. Ensure \texttt{newDeposit} = \texttt{deposited} = 5}
\item{The user decides to make another deposit in the same period of +3. Now \texttt{newDeposit} = \texttt{deposited} = 8 with everything else unchanged. Note: withdrawals withdraw \textit{everything} so we can ignore incremental withdrawals.}
\item{If the user decides to withdraw, the validator should check they can withdraw \texttt{deposited} = 8 plus any rewards.  Rewards would be calculated from interest acquired by \\ \texttt{deposited} - \texttt{newDeposit} + \texttt{rewards} = 8 - 8 + 0 = 0. In other words, their recent deposits should have zero rewards. Also, they have zero rewards in the first place, so can only withdraw their deposit (8). This formula is a special case of the formula in $\texttt{upp'userLength}\ 1$ (see \texttt{withdrawRewards}) where rewards are always zero.}
\end{itemize}
}


\item{\texttt{upp'adminLength} 0
\begin{itemize}
\item{Note: admin does not update \texttt{rewards} as we are yet to complete a bonding cycle (\texttt{upp'bondingLength}). This is a special case for the \textbf{first} admin windows, subsequent admin windows will update rewards for the previous bonding window, but because there was no prior bonding, we have no rewards. This also happens to coincide with the \texttt{updatedRewards} formula in $\texttt{upp'adminLength}\ 1$, where $\texttt{updatedRewards} = 0 + (8 - 8 + 0) = 0$}
\item{After ``updating rewards to zero", admin resets  all Assoc. List UTXOs \texttt{newDeposit} to zero}
\item{After ``updating rewards to zero", admin updates \texttt{totalDeposited} by summing all deposits and rewards off chain (using Assoc. List UTXOs)}
\item{After ``updating rewards to zero", admin picks rewards for the upcoming cycle and updates all \texttt{totalRewards} accordingly.}

\end{itemize}
}

\item{\texttt{upp'bondingLength} 0
\begin{itemize}
\item{Bonding begins for this cycle, the user can withdraw whenever. Should they decide to withdraw, they will get the following rewards: \\ $\texttt{withdrawRewards} = \texttt{rewards} + \frac{f}{(1 + \texttt{upp'interest})^k}$

 where $1 \leq k \leq \texttt{upp'increments}$
for the appropriate $k$ which should be on-chain verified. The user can submit their $k$ off chain via the appropriate \texttt{POSIXTimeRange} and the validator will check this range has the correct difference (delta). At this point, \texttt{rewards} is still zero but we get interest from our deposit as intended. Furthermore, the user will withdraw their \texttt{deposited} of course. This is \textit{not} an update on the datum (\texttt{EntryDatum}) but an actual withdrawal (burning the token). $f$ is a user factor defined as $f := \frac{\texttt{deposited} - \st{\texttt{newDeposit}} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$. Note the inverse relation between $k$ and time passed by, as we reach the end of the bonding period, $k$ tends to 1 so we get almost the proportioned rewards. Also note that \textbf{\texttt{newDeposit} is zero here from the previous Admin cycle}}
\item{If they decide to not withdraw, they will reach the next deposit/withdrawal cycle.}
\end{itemize}
}

\item{\texttt{upp'userLength} 1
\begin{itemize}
\item{With \texttt{newDeposit}'s reset to zero. The user decides to make a further deposit +2 (they do not have to of course). So $\texttt{newDeposit}=2$ and $\texttt{deposited}=10$ (incremented).}
\item{If the user decides to withdraw here, the user will get (along with \texttt{deposited}) \\ $\texttt{withdrawRewards} = \texttt{rewards} +  f$, no $k$ because they come from the just-completed  bonding cycle. As before, this is \textit{not} an update on the datum but an actual withdrawal (burning the token). We subtract \texttt{newDeposit} so they cannot get unearned rewards from depositing and withdrawing in the same cycle.

$f$ is a user factor defined as $f := \frac{\texttt{deposited} - \texttt{newDeposit} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$
}
\item{We emphasise: no rewards accrue during \texttt{upp'userLength}s}
\end{itemize}
}


\item{\texttt{upp'adminLength} 1
\begin{itemize}
\item{Finally, if the user did not withdraw in the recent deposit/withdrawal cycle (with previously accrued rewards), the admin updates rewards of this user to \\ $\texttt{updatedRewards} = \texttt{rewards} + f $ with $f := \frac{\texttt{deposited} - \texttt{newDeposit} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$. This is an increment on the original \texttt{rewards} from recent bonding cycle. This update should be reflected in the datum}
\item{After updating rewards, admin resets all Assoc. List UTXOs \texttt{newDeposit} to zero}
\item{After updating rewards, admin updates \texttt{totalDeposited} by summing all deposits (including rewards) off chain (using Assoc. List UTXOs) for the upcoming cycle}
\item{After updating rewards, admin picks rewards for the upcoming cycle and updates \texttt{totalRewards} accordingly.}
\end{itemize}
}
To prevent contention, the admin should only be able to close a pool during \texttt{upp'adminLength}. The admin should update all \texttt{open} fields to \texttt{False} (including the NFT State UTXO). At this point, the admin should update rewards so users can withdraw \texttt{deposited} + \texttt{rewards} (not needing to worry about the calculation). This is the same \texttt{rewards} calculation used in any other \texttt{upp'adminLength}. This seems trustless but the validator could verify this too. For now, we leave it for the user to withdraw their tokens (and not the admin to distribute but we can change this). Should the admin decide to close, \texttt{totalRewards} and \texttt{totalDeposited} fields do not matter, \texttt{rewards} should be updated so users can simply withdraw (\texttt{deposited} + \texttt{rewards}) in a straightforward manner.
\end{enumerate}

\label{section:unbondedSchema}
\subsection{User Stake}\label{subsection:userStake}
A user stake requires the Assoc. List UTXO from Subsection~\ref{subsection:AssociatedListMintingPolicy} to be minted (initial deposit) \textit{or} the Assoc. List UTXO to be spent (further deposits).

\subsubsection{On Chain}\label{subsubsection:userStakeOnchain}
Overlapping on-chain conditions for any type of deposit (initial or subsequent) with \texttt{StakeAct} redeemer (see Definition~\ref{def:StakeAct}), if any of these conditions do not hold, validation should fail,

\begin{itemize}
\item{Signed by \texttt{PaymentPubKeyHash} from the redeemer. The list of signers should be a singleton list}
\item{Transaction must occur after \texttt{upp'start} and in any \texttt{upp'userLength} period (abusing terminology slightly).}
\item{Check the requested stake amount is positive (since \texttt{Natural} includes zero)}
\item{Check the correct amount of the unbonded asset class (see Definition~\ref{def:upp'unbondedAssetClass}) is deposited to the validator address with \texttt{AssetDatum} as datum (see Definition~\ref{def:AssetDatum})}
\item{The user cannot withdraw any (staked) asset UTXOs}
\item{Check the \texttt{newDeposit} (Definition~\ref{def:newDeposit}) field has been initiated (first deposit of the cycle) or incremented (redeposits during the \textit{same} cycle)
\begin{enumerate}
\item{In particular, initial new deposits for a given cycle are $0 \rightarrow \texttt{amount}$}
\item{Redeposits during the \textit{same} cycle will have $\texttt{updatedNewDeposit} \rightarrow \texttt{prevNewDeposit + amount}$ for a given UTXO}
\end{enumerate}}
\end{itemize}
For the field \texttt{deposited} (not \texttt{newDeposit}), further conditions required for an \textbf{Initial deposit (insertion):}
\begin{itemize}
\item{Check the inductive conditions from Subsection~\ref{subsection:staking}, this means there may be different combinations of UTXOs minted, spent (and sent back to the validator) depending on the insertion type. At a high level, check a UTXO with \texttt{CurrencySymbol}, \texttt{upp'assocListCs} and \texttt{TokenName = TokenName hashedPkh} is minted, where \texttt{hashedPkh} is defined in \ref{def:hashedPkh}. Check the corresponding \texttt{EntryDatum} datum from Definition~\ref{def:EntryDatum} has been initiated accordingly, namely with \textit{correct amount deposited, zero rewards etc.} This UTXO should be sent to the validator and inserted into the correct position of the on-chain associated list. If the NFT State UTXO is spent (as part of induction), it must be sent back to the validator also, potentially altered by head insertion}
\item{Related to the previous, \texttt{txInfoMint} contains exactly one \texttt{AssetClass} of $1$ value. The \texttt{CurrencySymbol} should be checked with \ref{def:assocListCs} and \texttt{TokenName} with the (hashed) signer}
\item{Check the requested stake amount is between the minimum and maximum allowed amount (inclusive of bounds say), see Definitions~\ref{def:upp'minStake},~\ref{def:upp'maxStake}. This enables users to stake multiple times (see \textbf{Further deposits} below)}
\item{The \texttt{open} must be initiated as \texttt{True} (with neighbouring inductive UTXO(s) also \texttt{True})}
\end{itemize}
For the field \texttt{deposited} (not \texttt{newDeposit}), further conditions required for a \textbf{Further deposits (update):}
\begin{itemize}
\item{Since induction was already used for the initial deposit, we just need to spend Assoc. List UTXO of the user looking to make further deposits.}
\item{We can verify the correct UTXO is being spent by comparing \texttt{CurrencySymbol}, \texttt{upp'assocListCs} and \texttt{TokenName = TokenName hashedPkh}, where \texttt{hashedPkh} is defined in \ref{def:hashedPkh}.}
\item{The corresponding \texttt{EntryDatum} datum from Definition~\ref{def:EntryDatum} has been \textit{incremented} accordingly e.g. the \texttt{deposited} field. We should check the incremented amount is between the minimum and maximum allowed amount (inclusive of bounds say), see Definitions~\ref{def:upp'minStake},~\ref{def:upp'maxStake}.  Its \texttt{key} can also be verified} 
\item{This Assoc. List UTXO should be sent to the validator otherwise unchanged.}
\item{The \texttt{open} must be \texttt{True} when redepositing and stay \texttt{True}}
\end{itemize}
Note we are checking increments for both \texttt{newDeposit} and \texttt{deposited} separately, the former is needed by the admin in Subsection~\ref{subsection:adminDeposit}. Although since \texttt{newDeposit} isn't type \texttt{Maybe}, we can just treat them the same.
\subsubsection{Off Chain}\label{subsubsection:userStakeOffchain}
Using the \texttt{stakeAct} redeemer:
\begin{itemize}
\item{Signed by \texttt{PaymentPubKeyHash} from the redeemer and only this user}
\item{Calculate the relevant \texttt{POSIXTimeRange} for the transaction to fall inside the \texttt{upp'userLength} for user staking. You may need to get the current \texttt{POSIXTime} off chain}
\item{The user needs to query UTXOs at the validator address to find their position in the associated list. If they are not in the list, this is an \textbf{initial deposit} so the associated list minting policy from subsection~\ref{subsection:AssociatedListMintingPolicy} must be called with relevant inductive conditions. These essentially mirror the validator's conditions. Otherwise, if they are already in the list, this is a \textbf{further deposit}. For example, the \texttt{newDeposit} (Definition~\ref{def:newDeposit}) field is initiated correctly (first deposit of the cycle) or incremented (redeposits in the same cycle) in the output (and sent to the validator) etc.}
\item{Deposit the correct amount of the unbonded asset class (see Definition~\ref{def:upp'unbondedAssetClass}) to the validator address with \texttt{AssetDatum} as datum (see Definition~\ref{def:AssetDatum})}
\end{itemize}
For \textbf{Initial deposits}:
\begin{itemize}
\item{Call the minting policy as above and send the relevant minted Assoc. List UTXO to validator address. The \texttt{EntryDatum} must be initiated as specified by the validator/inductive conditions ($\texttt{deposited} = \texttt{amount}$, $\texttt{rewards} = 0$ etc.)}
\end{itemize}
For \textbf{Further deposits}:
\begin{itemize}
\item{Spend the Assoc. List UTXO and increment the the \texttt{deposited} (and \texttt{newDeposited}) field (in \texttt{EntryDatum}) by the amount deposited and nothing else changed. See the induction conditions for more details}
\end{itemize}

\subsection{Admin Deposit (Bonding Period)}\label{subsection:adminDeposit}
The admin should update Assoc. List UTXOs and deposit rewards for users. Use \\ $\texttt{adminAct newTotalRewards newTotalDeposited}$.  The admin is required to update the said UTXOs \textit{during} the designated admin window (\texttt{upp'adminLength}) to:
\begin{enumerate}
\item{Update the datum's \texttt{rewards}, $\texttt{updatedRewards} = \texttt{rewards} + f $ with $f := \frac{\texttt{deposited} - \texttt{newDeposit} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$. These are just rewards for the last complete bonding period (which would exclude any new deposits). Note this is zero for the \textbf{first} admin period since $\texttt{rewards}=0$ and $\texttt{deposited} = \texttt{newDeposit}.$}
\item{\textit{After} the above, update Assoc. List datum's \texttt{newDeposit} to zero}
\item{\textit{After} \texttt{rewards} are updated, set the datum's \texttt{totalRewards} (Definition~\ref{def:totalRewards}) to something \textit{new} (admin's choice)}
\item{\textit{After} \texttt{rewards} are updated, set the datum's \texttt{totalDeposited} (Definition~\ref{def:totalDeposited}) to how much has be deposited (including rewards) in total so far (this can be checked off chain).}

\end{enumerate}

Recall, we are (admin) depositing for the \textit{upcoming} bonding cycle and updating rewards for the \textit{most recently passed} bonding cycle. These increments mean we don't need an entire timestamp history of deposits, instead we have a Markov-like structure (without probability).

\subsubsection{On chain}
If any of these conditions do not hold, validation should fail,
\begin{itemize}
\item{Signed by \texttt{upp'admin}, contained in the Subsection~\ref{subsection:validatorParams}}
\item{Transaction must occur after \texttt{upp'start} \textit{and} in any \texttt{upp'adminLength} period (abusing terminology), which can easily be calculated on chain}
\item{Multiple Assoc. List UTXOs (\textit{not} NFT State Token) can be spent and updated. The \texttt{Entry}(\texttt{Datum}) type of \textit{inputs} should be:
\begin{minted}{haskell}
Entry
  { key = _
  , deposited = amount
  , newDeposit = newDeposit
  , rewards = rewards
  , totalRewards = _ 
  , totalDeposited = _
  , open = True -- must be open
  , next = _
  }
\end{minted}
}

\item{These should be updated to:
\begin{minted}{haskell}
Entry
  { key = _ -- unchanged
  , deposited = amount -- unchanged
  , newDeposit = 0 -- reset to zero
  , rewards = updatedRewards
  , totalRewards = newTotalRewards 
  , totalDeposited = newTotalDeposited
  , open = True -- unchanged
  , next = _ -- unchanged
  }
\end{minted}

}



\item{Here, $\texttt{updatedRewards}$ (as recently defined) should be deposited to the validator for each user (with datum \texttt{AssetDatum} and rounding up to be safe).
We should be very careful about rounding when admin depositing as user withdrawals in Subsection~\ref{subsection:UserWithdraw} will also round (down) and we do not want insufficient funds at the validator. Recall that \texttt{updatedRewards} are calculated before reseting \texttt{rewards} to zero (as we need to know how much was deposited recently).
}
\item{Since this is not entirely trustless, we could ensure  $\texttt{rewards} \leq \texttt{updatedRewards}$ on chain, it should be impossible to reduce any already accrued rewards. We can of course verify \texttt{updatedRewards} using the redeemer parameters}
\item{\texttt{totalRewards} and \texttt{totalDeposited} are updated via the admin act parameters.}
\item{All updated Assoc. List UTXOs must be sent back to the validator, otherwise unchanged}
\item{The admin cannot withdraw (staked) asset UTXOs}
\end{itemize}
\subsubsection{Off chain}
Using the $\texttt{adminAct newTotalRewards newTotalDeposited}$ redeemer:
\begin{itemize}
\item{The admin should sign the transaction}
\item{Calculate the relevant \texttt{POSIXTimeRange} for the transaction to fall inside the \texttt{upp'adminLength}. You may need to get the current \texttt{POSIXTime} off chain}
\item{The admin should find all UTXOs at the validator with \texttt{assocListCs} as its \texttt{CurrencySymbol} to create the above transaction, updating the datums in the same way that the validator requires}
\item{Batching of UTXOs can be done to save on the total number of transactions. Saving already dealt with UTXOs locally could help with not adding rewards twice}
\item{The UTXOs carrying the staked asset with datum \texttt{AssetDatum} may be separated into unit (valued) UTXOs or at least a UTXO per user to help with contention issues during withdrawal. The first option will cost more due to minimum Ada requirements}
\end{itemize}

\subsection{User Withdraw}\label{subsection:UserWithdraw}

\subsubsection{On chain}\label{subsection:UserWithdrawOnChain}
A user must withdraw \textit{all} their staked tokens and rewards in one transaction with \texttt{WithdrawAct} redeemer (see Definition~\ref{def:WithdrawAct}), if any of these conditions do not hold, validation should fail
\begin{itemize}
\item{Signed by \texttt{PaymentPubKeyHash} from the redeemer. The list of signers should be a singleton list}
\item{Transaction must occur after \texttt{upp'start} \textit{and} in any \texttt{upp'userLength} \textit{or} \texttt{upp'bondingLength} period (abusing terminology slightly), which can easily be calculated on chain. We can relax this condition if the pool is \textbf{closed} (\texttt{False})}
\item{Check the inductive conditions from Subsections~\ref{subsection:WithdrawingOpen}, \ref{subsection:WithdrawingClosed}, this means there may be different combinations of UTXOs burned, spent (and sent back to the validator) depending on the removal type. At a high level, check a UTXO with \texttt{CurrencySymbol}, \texttt{upp'assocListCs} and \texttt{TokenName = TokenName hashedPkh} is burned, where \texttt{hashedPkh} is defined in \ref{def:hashedPkh}. 

Definition~\ref{def:EntryDatum} provides the correct withdrawal rewards amount during \texttt{upp'bondingLength}:
\begin{enumerate}
\item{\textbf{Closed pool:}
 $\texttt{rewards}$.  Recall, the admin sorts out the rewards in the closing admin cycle}
\item{\textbf{Open pool:} $\texttt{withdrawRewards} = \texttt{rewards} + \frac{f}{(1 + \texttt{upp'interest})^k}$

 where $1 \leq k \leq \texttt{upp'increments}$ with $f := \frac{\texttt{deposited} - \st{\texttt{newDeposit}} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$. $k$ can be found off chain via the correct \texttt{POSIXTimeRange} and its length (delta) should be verified on chain. Note that \texttt{newDeposit} was recently set to zero, furthermore, there is an inverse relation betweek $k$ and time passed. As we tend towards the end of the bonding period, $k=1$ and we almost get all rewards. But closer to the start, $k \sim \texttt{upp'increments}$ and we get less.}
\end{enumerate}

The withdrawal during \texttt{upp'userLength} is:
\begin{enumerate}
\item{\textbf{Closed pool:}
 $\texttt{rewards}$.  Recall, the admin sorts out the rewards in the closing admin cycle. Same as before.}
\item{\textbf{Open pool:} $\texttt{withdrawRewards} = \texttt{rewards} + f$
with $f := \frac{\texttt{deposited} - \texttt{newDeposit} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$. These are rewards for the last completed bonding cycle that should not include any recent deposits whilst open.}
\end{enumerate}

 If the NFT State UTXO is spent (as part of \textbf{open withdrawal} induction), it must be sent back to the validator also, potentially altered by head withdrawal. The on-chain associated should be correctly updated as part of the inductive conditions.
 
To make withdrawals flexible, we can bound the allowed withdrawal amount to be  $\texttt{deposited} \leq \texttt{withdrawalAmount} \leq \texttt{deposited} + \texttt{(updated)Rewards}$ (per user) to prevent insufficient fund issues stopping a deposit withdrawal atleast.
 }
\item{Related to the previous, \texttt{txInfoMint} contains exactly one \texttt{AssetClass} of $-1$ value. The \texttt{CurrencySymbol} should be checked with \ref{def:assocListCs} and \texttt{TokenName} with the (hashed) signer}
\item{Check the correct amount from of the unbonded asset class (see Definition~\ref{def:upp'unbondedAssetClass}) is sent to the signer's address (from the validator). The validator can round rewards down when validating withdrawals. The datum of these UTXOs can be checked as \ref{def:AssetDatum} in the input and output.} 
\end{itemize}
We should emphasise that care is needed on rounding behaviour when withdrawing as the requested withdrawal amount off chain must match what the validator expects.


\subsubsection{Off chain}\label{subsection:UserWithdrawOffchain}
With the \texttt{WithdrawAct} redeemer:
\begin{itemize}
\item{Signed by \texttt{PaymentPubKeyHash} from the redeemer and only this user}
\item{Calculate the relevant \texttt{POSIXTimeRange} for the transaction to fall inside the \texttt{upp'userLength} or \texttt{upp'bondingLength}. Withdrawing during bonding will require a \texttt{POSIXTimeRange} of ``length"  \texttt{upp'interestLength}. You may need to get the current \texttt{POSIXTime} off chain}
\item{The user needs to query UTXOs at the validator address to find their position in the associated list. If they are not in the list, cancel the transaction, otherwise, burn their Assoc. List Token; requiring the associated list minting policy from subsection~\ref{subsection:AssociatedListMintingPolicy} to be called with relevant inductive conditions.}
\item{Withdraw the correct amount of the unbonded asset class (see Definition~\ref{def:upp'unbondedAssetClass}) to the user address with \texttt{AssetDatum} as datum (see Definition~\ref{def:AssetDatum}), sending any change back to the validator.}
\end{itemize}
\subsection{Admin Close}
With the \texttt{CloseAct} redeemer (see Definition~\ref{def:CloseAct}), 

\subsubsection{On Chain}
\begin{itemize}
\item{Signed by \texttt{upp'admin}, contained in the Subsection~\ref{subsection:validatorParams}}
\item{Transaction must occur after \texttt{upp'start} and during \texttt{upp'adminLength}}
\item{Check all \texttt{open} fields are set to \texttt{False} on NFT State and Assoc. List UTXOs.}
\item{Check \texttt{rewards} has been updated using the formula for updating in a normal \texttt{upp'adminLength}. Namely, rewards for the most recently completed bonding cycle.}
\textit{Other fields are irrelevant now so we can leave them unchanged.}
\end{itemize}

\subsubsection{Off Chain}
\begin{itemize}
\item{Signed by \texttt{upp'admin}}
\item{Create a transaction with \texttt{POSIXTimeRange} during a \texttt{upp'adminLength}}
\item{Spend all relevant UTXOs and change all \texttt{open} fields are set to \texttt{False}, sending back the validator.}
\item{For now, we leave it for individual users to withdraw their tokens, as they will want to burn their Assoc. List UTXOs for min Ada too.}
\item{Work out rewards for users and update their \texttt{rewards} field. Leave Assoc. List UTXOs at the validator that users will need to withdraw/burn to get their min Ada.}
\item{Withdraw the NFT State UTXO to the admin address as this is not needed for \textbf{closed} withdrawing - see Subsection~\ref{subsection:WithdrawingClosed}}
\item{Calculate how many tokens are not part of rewards off chain and withdraw leftovers to admin. This requires admin trust and could potentially be made trustful with a folding datum and proof of how much is leftover (ignore this for simplicity)}
\end{itemize}

\subsection{User Query}\label{subsection:UserQuery}
Write a simple contract for a user to query their \texttt{EntryDatum} on the on-chain associated list. This is purely off chain and does not require validation logic.

\subsection{Deposited Query}\label{subsection:DepositedQuery}
Write a simple contract for a user to query the total amount deposited at the validator. This should focus on the Assoc. List UTXO datums only (\texttt{deposited} field) as people could waste their tokens by sending to the validator. This is purely off chain and does not require validation logic.

\section{Induction Conditions}\label{section:Induction}
\textbf{This section is different to that of bonded staking.}

These conditions are needed on the minting policy and validator. The scripts should prove that its \texttt{CurrencySymbol} can only be minted to insert (deposit stake) or remove (withdraw stake) from the associated list. These assume the NFT State UTXO has already been deposited at the validator address.

For \textbf{Staking}, we always mint 1 token. Notice that by construction below, we can only mint this token once for an individual user due to inequality conditions. This does not prevent multiple deposits by a user, as they would ignore the minting policy for non-initial deposits.
For \textbf{Withdrawing}, we always burn 1 token.

\subsection{Staking}\label{subsection:staking}

It is important to realise that multiple deposits by a given user for staking does not involve minting a new token. Therefore, all the reward amounts below are initialised to zero for minting/depositing.

\subsubsection{Head Stake}\label{subsubsection:HeadStake}
A head stake is when the NFT State UTXO is already at the validator address and we want to either initiate or alter the head element
\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Stake} minting redeemer, \ref{def:Stake}. In this case, check the NFT State UTXO is part of the inputs (with no other inputs of \texttt{CurrencySymbol}, \texttt{assocListCs}, see Definition~\ref{def:assocListCs}). Therefore, checks are automatically forwarded to the validator.}
\item{\textbf{Implied Validator logic:} Use the \texttt{StakeAct} validator redeemer, \ref{def:StakeAct} with a singleton signature for the transaction. This signature provides the key, \texttt{hashedPkh} and \texttt{TokenName} of course. There are two scenarios:

\begin{itemize}
\item{For the initial head stake, check the NFT State UTXO is part of the inputs with datum \texttt{StateDatum Nothing True} (fail with \texttt{False}). Also check the NFT State UTXO has output datum \texttt{StateDatum (Just hashedPkh) True} with the relevant \texttt{TokenName = TokenName hashedPkh} from \ref{def:hashedPkh} and everything else unchanged. We should check the associated list UTXO has been deposited to the validator, with \texttt{assocListCs} as \texttt{CurrencySymbol} and datum
\begin{minted}{haskell}
Entry
  { key = hashedPkh
  , deposited = amount
  , newDeposit = Just amount -- new deposit to help with rewards calculation
  , rewards = 0 -- initiate to zero
  , totalRewards = 0 -- admin can update for upcoming cycle
  , totalDeposited = 0 -- admin can update for upcoming cycle
  , open = True -- by induction of an open pool
  , next = Nothing
  }
\end{minted}
The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s, where outputs will contain the minted UTXO in question. Note that the validator is essentially doing minting checks.

The \texttt{newDeposit} should be initiated by the amount deposited. Incrementing occurs when the user deposits multiple times in \textit{one} cycle, but this won't happen here since we are minting.

The \texttt{amount} of staking UTXOs should be deposited to the validator of course.

Note: the initial head stake is equivalent to an initial tail stake so do not define the latter.
}

\item{
For altering the head, check the NFT State UTXO is part of the inputs with datum \texttt{StateDatum (Just currentHead) True}. Check the proposed hashed \texttt{BuiltinByteString}, \texttt{proposedHead} is \textbf{less} than \texttt{currentHead}. Also check the NFT State UTXO has output datum \texttt{StateDatum (Just proposedHead) True} with the relevant \texttt{TokenName = TokenName proposedHead} from \ref{def:hashedPkh} and everything else unchanged. We should check the associated list UTXO has been deposited to the validator, with \texttt{assocListCs} as \texttt{CurrencySymbol} and datum
\begin{minted}{haskell}
Entry
  { key = proposedHead
  , deposited = amount
  , newDeposit = Just amount -- new deposit to help with rewards calculation
  , rewards = 0 -- initiate to zero
  , totalRewards = 0 -- admin can update for upcoming cycle
  , totalDeposited = 0 -- admin can update for upcoming cycle
  , open = True -- by induction of an open pool
  , next = Just currentHead
  }
\end{minted}
The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s, where outputs will contain the minted UTXO in question.

The \texttt{newDeposit} should be initiated by the amount deposited. Incrementing occurs when the user deposits multiple times in \textit{one} cycle, but this won't happen here since we are minting.

The \texttt{amount} of staking tokens should again be deposited to the validator of course.
}

\end{itemize} 

}
\end{enumerate}

\subsubsection{Inbetween Stake}\label{subsubsection:InbetweenStake}
Given head insertions, there can now be a chain of Assoc. List  UTXOs at the validator. An inbetween stake is where we mint (deposit) a token between two Assoc. List UTXOs (note, the NFT State UTXO must not be included) but the validator will be invoked by both UTXOs by induction.
\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Stake} minting redeemer, \ref{def:Stake}. Check there are two Assoc. List UTXOs are part of the input. Both UTXOs will invoke the validator so adjacency checks can be forwarded. To be stringent, we make sure the NFT State UTXO is not part of the inputs.
}

\item{\textbf{Implied Validator logic:} Use the \texttt{StakeAct} validator redeemer, \ref{def:StakeAct} with a singleton signature for the transaction. This signature provides the proposed key, \texttt{middleKey} and \texttt{TokenName} of course. Check there are two \textit{adjacent} Assoc. List state UTXOs as part of the input. Adjacency can be checked by verifying the existence of the following datum structure (along with their \texttt{CurrencySymbol} \& \texttt{TokenName}s):
\begin{minted}{haskell}
Entry
  { key = firstKey
  , deposited = amount
  , newDeposit = firstNewDeposit
  , rewards = firstRewards
  , totalRewards = firstTotalRewards
  , totalDeposited = firstTotalDeposited
  , open = True -- by induction of an open pool
  , next = Just secondKey -- crucial
  }

Entry
  { key = secondKey
  , deposited = _
  , newDeposit = _
  , rewards = _
  , totalRewards = _ -- may be different to firstTotalRewards in a deposit cycle
  -- across different Entries and should be fixed during upcoming admin cycle
  , totalDeposited = _ -- may be different to firstTotalDeposited in a deposit
  -- cycle across different Entries and should be during upcoming admin cycle
  , open = True -- should be the same
  , next = _
  }
\end{minted}

Check that:  $\texttt{firstKey} < \texttt{middleKey} < \texttt{secondKey}.$ The \texttt{TokenName} of the newly minted UTXO should be \texttt{TokenName middleKey} of unit value.

Check that: \texttt{open} is invariant. \texttt{totalRewards} and \texttt{totalDeposited} need not be invariant as the admin will fix this for the upcoming cycle.

 We should check the associated list UTXO has been deposited to the validator, with \texttt{assocListCs} as \texttt{CurrencySymbol} and datum
\begin{minted}{haskell}
Entry  
  { key = middleKey
  , deposited = amount'
  , newDeposit = Just amount'
  , rewards = 0
  , totalRewards = 0
  , totalDeposited = 0
  , open = True
  , next = Just secondKey -- this middle UTXO now points to the latter UTXO
  }
\end{minted}

The previous first entry should have its datum changed to \begin{minted}{haskell}
Entry
  { key = firstKey -- unchanged
  , deposited = amount -- unchanged
  , newDeposit = firstNewDeposit -- unchanged
  , rewards = firstRewards -- unchanged
  , totalRewards = firstRewards -- unchanged
  , totalDeposited = firstTotalDeposited -- unchanged
  , open = True -- unchanged
  , next = Just middleKey -- the first UTXO now points to the middle UTXO
  }
\end{minted}

The second entry should be unchanged in datum and value.

The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s, where outputs will contain the minted UTXO in question.

The \texttt{newDeposit} should be initiated by the amount deposited. Incrementing occurs when the user deposits multiple times in \textit{one} cycle, but this won't happen here since we are minting.

The \texttt{amount'} of staking tokens should be deposited to the validator of course.
}
\end{enumerate}



\subsubsection{Tail Stake}\label{subsubsection:TailStake}
We complete the induction by validating tail insertions:
\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Stake} minting redeemer, \ref{def:Stake}. Check the Assoc. List UTXO (exactly one) is part of the inputs without the NFT State UTXO. Checks are then forwarded to the validator.
}

\item{\textbf{Implied Validator logic:} Use the \texttt{StakeAct} validator redeemer, \ref{def:StakeAct} with a singleton signature for the transaction. This signature provides the proposed key, \texttt{tailKey} and \texttt{TokenName} of course. Check there is exactly one Assoc. List state UTXOs as part of the input (without NFT State UTXO). Verifying it is indeed the tail can be checked by observing the following datum structure (along with the usual \texttt{CurrencySymbol} checks):
\begin{minted}{haskell}
Entry
  { key = tailKey
  , deposited = amount
  , newDeposit = tailNewDeposit
  , rewards = tailRewards
  , totalRewards = tailTotalRewards
  , totalDeposited = tailTotalDeposited
  , open = True -- by induction of an open pool
  , next = Nothing -- Nothing means it is the tail
  }
\end{minted}

Check that: $\texttt{tailKey} < \texttt{proposedTailKey}.$ The \texttt{TokenName} of the newly minted UTXO should be \texttt{TokenName proposedTailKey} of unit value.

 We should check the associated list UTXO has been deposited to the validator, with \texttt{assocListCs} as \texttt{CurrencySymbol} and datum (this part of the minting check)
\begin{minted}{haskell}
Entry
  { key = proposedTailKey
  , deposited = amount'
  , newDeposit = Just amount'
  , rewards = 0
  , totalRewards = 0 
  , totalDeposited = 0
  , open = True -- by induction of an open pool
  , next = Nothing -- it is the new tail
  }
\end{minted}

The previous tail should have its datum changed to \begin{minted}{haskell}
Entry
  { key = tailKey -- unchanged
  , deposited = amount -- unchanged
  , newDeposit = tailNewDeposit -- unchanged
  , rewards = tailRewards -- unchanged
  , totalRewards = tailTotalRewards -- unchanged
  , totalDeposited = tailTotalDeposited -- unchanged
  , open = True -- unchanged
  , next = Just proposedTailKey -- the previous tail now points to the new tail
  }
\end{minted}

The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s, where outputs will contain the minted UTXO in question.

The \texttt{newDeposit} should be initiated by the amount deposited. Incrementing occurs when the user deposits multiple times in \textit{one} cycle, but this won't happen here since we are minting.

The \texttt{amount'} of staking tokens should be deposited to the validator of course.
}
\end{enumerate}

\subsection{Withdrawing (\textbf{Open Pool})}\label{subsection:WithdrawingOpen}
For withdrawing, the minting policy should check the relevant UTXOs are part of the inputs. Checks on -1 valued being minted with the correct \texttt{TokenName = TokenName hashedPkh} can be forwarded to the validator as previously.


\subsubsection{Head Withdraw}\label{subsubsection:HeadWithdraw}
The head withdraw is when the NFT State UTXO and head Assoc. List UTXOS are already at the validator address and being validated.
\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Withdraw} minting redeemer, \ref{def:Withdraw}. In this case, check the NFT State UTXO and exactly one Assoc. List UTXO is part of the inputs. Therefore, checks (like checking it is indeed the head) are automatically forwarded to the validator by staking/deposit induction.}
\item{\textbf{Implied Validator logic:} Use the \texttt{WithdrawAct} validator redeemer, \ref{def:WithdrawAct} with a singleton signature for the transaction. This signature provides the key, \texttt{currentHead} and \texttt{TokenName} of course. There are two scenarios:

\begin{itemize}
\item{When the list only consists of the head element, check the NFT State UTXO is part of the inputs with datum \texttt{StateDatum (Just currentHead) True} (see Subsection~\ref{subsection:WithdrawingClosed} for closed withdrawals). Also check the NFT State UTXO has output datum \texttt{StateDatum Nothing True} (unchanged) and everything else unchanged. We should check the associated list UTXO is part of the input and being burnt, with \texttt{assocListCs} as \texttt{CurrencySymbol} and datum
\begin{minted}{haskell}
Entry
  { key = currentHead
  , deposited = amount
  , newDeposit = _
  , rewards = rewards
  , totalRewards = totalRewards 
  , totalDeposited = totalDeposited
  , open = True -- open withdrawal
  , next = Nothing -- the list only contains one element
  }
\end{minted}

 We should check the associated list UTXO has been burnt (-1)

The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s. Note that the validator is essentially doing minting checks.

\begin{itemize}
\item{If \textbf{open} during \texttt{upp'userLength}, withdraw \texttt{amount} plus \\ $\texttt{withdrawRewards} = \texttt{rewards} + f$ with $f := \frac{\texttt{amount} - \texttt{newDeposit} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$ (rewards for the last bonding cycle).}
\item{If \textbf{open} during \texttt{upp'bondingLength}, withdraw \texttt{amount} plus \\ $\texttt{withdrawRewards} = \texttt{rewards} + \frac{f}{(1 + \texttt{upp'interest})^k}$ for $1 \le k \le \texttt{upp'increments}$
 with $f := \frac{\texttt{amount} - \st{\texttt{newDeposit}} + \texttt{rewards}}{\texttt{totalDeposited}} * \texttt{totalRewards}$ (rewards for current incomplete bonding window).}
\end{itemize}

This all assumes the admin doesn't automatically distribute rewards upon closure. This is all verifiable on chain.
}

\item{
When the list contains more than one element, check the NFT State and head Assoc. List UTXOs are part of the inputs with datum \texttt{StateDatum (Just currentHead)}. Check the proposed hashed \texttt{BuiltinByteString}, equals the \texttt{currentHead}. Also check the NFT State UTXO has output datum \texttt{StateDatum (Just newHead)} and everything else unchanged. \texttt{newHead} can be obtained by looking at the head UTXO with datum (this should be verified by checking its \texttt{TokenName} of course)
\begin{minted}{haskell}
Entry
  { key = currentHead
  , deposited = amount
  , newDeposit = _
  , rewards = rewards
  , totalRewards = totalRewards 
  , totalDeposited = totalDeposited
  , open = True -- open withdrawal
  , next = Just newHead -- the list contains more than one element
  }
\end{minted}


 We should check the associated list UTXO has been burnt (-1)

The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s.

The same amount of staking UTXOs should be withdraw to the address that hashes to \texttt{currentHead} from the validator address (see previous bullet point).
}

\end{itemize} 

}
\end{enumerate}


\subsubsection{Other Withdraw}\label{subsubsection:OtherWithdraw}
Other withdrawals is where we burn (-1) a token. Two list UTXOs (the NFT State UTXO must not be included). It is intended for the \textbf{latter} (ordered) UTXO to be withdrawn. The latter can be the tail or any UTXO after the head.
\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Withdraw} minting redeemer, \ref{def:Withdraw}. Check there are two Assoc. List UTXOs are part of the input. Both UTXOs will invoke the validator so adjacency checks can be forwarded. To be stringent, we make sure the NFT State UTXO is not part of the inputs.
}

\item{\textbf{Implied Validator logic:} Use the \texttt{WithdrawAct} validator redeemer, \ref{def:WithdrawAct} with a singleton signature for the transaction. This signature provides the proposed key, \texttt{withdrawKey} and \texttt{TokenName} of course. Check there are two \textit{adjacent} Assoc. List state UTXOs as part of the input. Adjacency can be checked by verifying the existence of the following datum structure (along with their \texttt{CurrencySymbol} \& \texttt{TokenName}s):
\begin{minted}{haskell}
Entry
  { key = firstKey
  , deposited = amount
  , newDeposit = firstNewDeposit
  , rewards = rewards
  , totalRewards = firstTotalRewards
  , totalDeposited = firstTotalDeposited
  , open = True -- open withdrawal
  , next = Just secondKey
  }
  
Entry
  { key = secondKey
  , deposited = amount'
  , newDeposit = _
  , rewards = rewards'
  , totalRewards = _ 
  , totalDeposited = _
  , open = True -- open withdrawal
  , next = secondNext
  }
\end{minted}

Check that: $\texttt{withdrawKey} == \texttt{secondKey}.$ The \texttt{TokenName} of the burnt UTXO should be \texttt{TokenName withdrawKey} of -1 value.

The first UTXO should have its datum changed to \begin{minted}{haskell}
Entry
  { key = firstKey -- unchanged
  , deposited = amount -- unchanged
  , newDeposit = firstNewDeposit -- unchanged
  , rewards = rewards -- unchanged
  , totalRewards = firstTotalRewards -- unchanged
  , totalDeposited = firstTotalDeposited -- unchanged
  , open = bool -- unchanged
  , next = secondNext -- the first UTXO now points to the UTXO after the second
  -- UTXO (if any) - it is Nothing if withdrawing the tail.
\end{minted}

The validator should check the (non staking) UTXOs are all unit value in inputs and outputs with correct \texttt{CurrencySymbol}s.

\begin{itemize}
\item{If \textbf{open} during \texttt{upp'userLength}, withdraw \texttt{amount'} plus \\ $\texttt{withdrawRewards'} = \texttt{rewards'} + f$
 with $f := \frac{\texttt{amount'} - \texttt{newDeposit'} + \texttt{rewards'}}{\texttt{totalDeposited}} * \texttt{totalRewards}$ (rewards for the last bonding cycle).}
\item{If \textbf{open} during \texttt{upp'bondingLength}, withdraw \texttt{amount'} plus \\ $\texttt{withdrawRewards'} = \texttt{rewards'} + \frac{f}{(1 + \texttt{upp'interest})^k}$ for $1 \le k \le \texttt{upp'increments}$
 with $f := \frac{\texttt{amount'} - \st{\texttt{newDeposit'}} + \texttt{rewards'}}{\texttt{totalDeposited}} * \texttt{totalRewards}$

 (rewards for current incomplete bonding window).}
\end{itemize}


This all assumes the admin doesn't automatically distribute rewards upon closure.This is all verifiable on chain.
}
\end{enumerate}

\subsection{Withdrawing (\textbf{Closed Pool})}\label{subsection:WithdrawingClosed}

For withdrawing, the minting policy should check the relevant UTXO (just the single Assoc. List UTXO of the user). Checks on -1 valued being minted with the correct \texttt{TokenName = TokenName hashedPkh} can be forwarded to the validator as previously.

\begin{enumerate}
\item{\textbf{Minting logic:} Use the \texttt{Withdraw} minting redeemer, \ref{def:Withdraw}. In this case, exactly one Assoc. List UTXO is part of the inputs (no NFT State UTXO). Therefore, checks are automatically forwarded to the validator by staking/deposit induction. We can \textbf{ignore} the requirement for the NFT State UTXO if the pool is closed as the admin will have withdrawn this. We do not need to update the ordering of the Assoc List UTXO because there will be no further deposits. }
\item{\textbf{Implied Validator logic:} Use the \texttt{WithdrawAct} validator redeemer, \ref{def:WithdrawAct} with a singleton signature for the transaction. This signature provides the key and \texttt{TokenName} of course. We just need to confirm we are burning this token and withdrawing \texttt{deposited} + \texttt{rewards} (\texttt{rewards} was already updated during the admin closure cycle)}

\end{enumerate}
\end{document}
